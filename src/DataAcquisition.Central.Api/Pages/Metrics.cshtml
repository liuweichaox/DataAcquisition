@page "/metrics"
@{
    ViewData["Title"] = "Á≥ªÁªüÊåáÊ†áÁõëÊéß";
    Layout = null;
}

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>@ViewData["Title"]</title>

    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css"/>
    <!-- Element Plus Icons -->
    <link rel="stylesheet" href="https://unpkg.com/@@element-plus/icons-vue/dist/index.css"/>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f7fa;
        }

        #app {
            min-height: 100vh;
        }

        .metrics-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .page-header {
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .page-header h2 {
            margin: 0;
            color: #303133;
            font-size: 20px;
            font-weight: 600;
        }

        .metric-card {
            margin-bottom: 20px;
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .metric-title {
            font-size: 16px;
            font-weight: 600;
            color: #303133;
        }

        .metric-value {
            font-size: 28px;
            font-weight: bold;
            color: #409eff;
            margin: 10px 0;
        }

        .metric-description {
            font-size: 12px;
            color: #909399;
            margin-top: 5px;
        }

        .metric-tags {
            margin-top: 10px;
        }

        .chart-wrapper {
            margin-top: 15px;
            height: 250px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .refresh-info {
            color: #909399;
            font-size: 12px;
        }

        .filter-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
        }

        .nav-menu {
            margin-bottom: 0;
        }

        .nav-menu-wrapper {
            max-width: 1400px;
            margin: 0 auto;
        }

        .nav-menu .el-menu-item {
            height: 60px;
            line-height: 60px;
            padding: 0 20px;
        }

        .nav-menu .el-menu-item.is-active {
            color: #409eff;
            border-bottom: 2px solid #409eff;
        }
    </style>
</head>

<body>
<div id="app">
    <partial name="_NavigationMenu"/>
    <div class="metrics-container">
        <div class="page-header">
            <div>
                <h2>
                    <el-icon>
                        <Monitor></Monitor>
                    </el-icon>
                    Á≥ªÁªüÊåáÊ†áÁõëÊéß
                </h2>
                <div class="refresh-info" style="margin-top: 5px;">
                    <span v-if="lastUpdate">ÊúÄÂêéÊõ¥Êñ∞: {{ lastUpdate }}</span>
                    <span v-else>Ê≠£Âú®Âä†ËΩΩ...</span>
                </div>
            </div>
            <div style="display: flex; gap: 12px; align-items: center;">
                <el-button type="primary" @@click="loadMetrics" :loading="loading">
                    <el-icon>
                        <Refresh/>
                    </el-icon>
                    Âà∑Êñ∞
                </el-button>
            </div>
        </div>

        <div class="filter-card">
            <el-row :gutter="20">
                <el-col :span="12">
                    <el-select v-model="selectedMetrics" multiple clearable collapse-tags filterable
                               placeholder="ÈÄâÊã©Ë¶ÅÂ±ïÁ§∫ÁöÑÊåáÊ†á" style="width: 100%;">
                        <el-option v-for="name in availableMetrics" :key="name" :label="getMetricTitle(name)"
                                   :value="name">
                        </el-option>
                    </el-select>
                </el-col>
                <el-col :span="6">
                    <el-input v-model="searchKeyword" placeholder="ÊêúÁ¥¢ÊåáÊ†áÂêçÁß∞" clearable
                              @@keyup.enter="searchMetrics">
                        <template #prefix>
                            <el-icon>
                                <Search/>
                            </el-icon>
                        </template>
                    </el-input>
                </el-col>
                <el-col :span="6">
                    <div style="display: flex; gap: 10px;">
                        <el-button type="primary" @@click="searchMetrics" :loading="loading" icon="Search">
                            ÊêúÁ¥¢
                        </el-button>
                        <el-button @@click="clearFilters" icon="Refresh">
                            Ê∏ÖÁ©∫
                        </el-button>
                    </div>
                </el-col>
            </el-row>
        </div>

        <div>
            <el-alert v-if="error" :title="error" type="error" :closable="false" style="margin-bottom: 20px;">
            </el-alert>

            <div v-if="loading && !metrics" style="text-align: center; padding: 40px;">
                <el-icon class="is-loading" style="font-size: 32px;">
                    <Loading/>
                </el-icon>
                <p style="margin-top: 10px; color: #909399;">Ê≠£Âú®Âä†ËΩΩÊåáÊ†áÊï∞ÊçÆ...</p>
            </div>

            <div v-else-if="Object.keys(metrics).length === 0" style="text-align: center; padding: 40px;">
                <el-empty description="ÊöÇÊó†ÊåáÊ†áÊï∞ÊçÆÔºåËØ∑Á°Æ‰øùÁ≥ªÁªüÊ≠£Âú®ËøêË°åÂπ∂‰∫ßÁîüÊåáÊ†á"></el-empty>
            </div>

            <div v-else>
                <!-- ÂÖ≥ÈîÆÊåáÊ†áÊ¶ÇËßà -->
                <el-card class="metric-card" shadow="hover">
                    <template #header>
                        <div class="metric-header">
                            <span class="metric-title">üìä ÂÖ≥ÈîÆÊåáÊ†áÊ¶ÇËßà</span>
                        </div>
                    </template>
                    <div class="stats-grid">
                        <el-statistic title="ÈááÈõÜÂª∂Ëøü" :value="getMetricValue('data_acquisition_collection_latency_ms')"
                                      suffix="ms">
                            <template #prefix>
                                <el-icon style="vertical-align: -0.125em;">
                                    <Timer/>
                                </el-icon>
                            </template>
                        </el-statistic>
                        <el-statistic title="ÈááÈõÜÈ¢ëÁéá" :value="getMetricValue('data_acquisition_collection_rate')"
                                      suffix="points/s">
                            <template #prefix>
                                <el-icon style="vertical-align: -0.125em;">
                                    <DataLine/>
                                </el-icon>
                            </template>
                        </el-statistic>
                        <el-statistic title="ÈòüÂàóÊ∑±Â∫¶" :value="getMetricValue('data_acquisition_queue_depth')"
                                      suffix="messages">
                            <template #prefix>
                                <el-icon style="vertical-align: -0.125em;">
                                    <Box/>
                                </el-icon>
                            </template>
                        </el-statistic>
                        <el-statistic title="ÈîôËØØÊÄªÊï∞" :value="getMetricValue('data_acquisition_errors_total')">
                            <template #prefix>
                                <el-icon style="vertical-align: -0.125em; color: #f56c6c;">
                                    <Warning/>
                                </el-icon>
                            </template>
                        </el-statistic>
                    </div>
                </el-card>

                <!-- ËØ¶ÁªÜÊåáÊ†áÂç°Áâá -->
                <el-card v-for="(metric, metricName) in filteredMetrics" :key="metricName" class="metric-card"
                         shadow="hover">
                    <template #header>
                        <div class="metric-header">
                            <span class="metric-title">{{ getMetricTitle(metricName) }}</span>
                            <el-tag :type="getMetricType(metric.type)">{{ metric.type }}</el-tag>
                        </div>
                    </template>

                    <div v-if="metric.data && metric.data.length > 0">
                        <!-- ÊúÄÊñ∞ÂÄº -->
                        <div class="metric-value">
                            {{ formatMetricValue(metricName, getLatestValue(metric.data).value ??
                                getLatestValue(metric.data)) }}
                        </div>

                        <!-- ÊèèËø∞ -->
                        <div class="metric-description" v-if="metric.help">
                            {{ metric.help }}
                        </div>

                        <!-- Ê†áÁ≠æ -->
                        <div class="metric-tags" v-if="getLatestValue(metric.data).labels">
                            <el-tag v-for="(value, key) in getLatestValue(metric.data).labels" :key="key"
                                    size="small" style="margin-right: 8px; margin-bottom: 8px;">
                                <strong>{{ key }}:</strong> {{ value }}
                            </el-tag>
                        </div>

                        <!-- ÂõæË°® -->
                        <div class="chart-wrapper" v-if="metric.data.length > 1">
                            <el-divider></el-divider>
                            <div :id="'chart-' + metricName" style="height: 250px;"></div>
                        </div>

                        <!-- Êï∞ÊçÆË°®Ê†º -->
                        <el-table v-if="metric.data.length > 0" :data="metric.data.slice(-10).reverse()"
                                  size="small" style="margin-top: 15px;" max-height="200">
                            <el-table-column prop="value" label="ÂÄº" width="120">
                                <template #default="scope">
                                    {{ formatMetricValue(metricName, scope.row.value) }}
                                </template>
                            </el-table-column>
                            <el-table-column label="Ê†áÁ≠æ" min-width="200">
                                <template #default="scope">
                                    <el-tag v-for="(value, key) in scope.row.labels" :key="key" size="small"
                                            style="margin-right: 5px;">
                                        {{ key }}: {{ value }}
                                    </el-tag>
                                </template>
                            </el-table-column>
                        </el-table>
                    </div>

                    <el-empty v-else description="ÊöÇÊó†Êï∞ÊçÆ" :image-size="80"/>
                </el-card>
            </div>
        </div>
    </div>
</div>

<!-- Vue 3 (production build) -->
<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<!-- Element Plus -->
<script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
<!-- Element Plus Icons -->
<script src="https://unpkg.com/@@element-plus/icons-vue/dist/index.iife.js"></script>
<!-- ECharts for charts -->
<script src="https://unpkg.com/echarts@5/dist/echarts.min.js"></script>

<script>
    const {createApp, ref, computed, onMounted, onUnmounted, watch} = Vue;
    const {ElMessage} = ElementPlus;
    // ÈÖçÁΩÆ‰∏≠ÊñáËØ≠Ë®ÄÂåÖ
    // ÊâãÂä®ÈÖçÁΩÆ Element Plus ‰∏≠ÊñáËØ≠Ë®Ä
    const zhCn = {
        el: {
            pagination: {
                goto: 'ÂâçÂæÄ',
                pagesize: 'Êù°/È°µ',
                total: 'ÂÖ± {total} Êù°',
                pageClassifier: 'È°µ',
                page: 'È°µ',
                prev: '‰∏ä‰∏ÄÈ°µ',
                next: '‰∏ã‰∏ÄÈ°µ',
                currentPage: 'ÂΩìÂâçÈ°µ',
                prevPages: 'ÂêëÂâç {pagerCount} È°µ',
                nextPages: 'ÂêëÂêé {pagerCount} È°µ'
            }
        }
    };

    const app = createApp({
        setup() {
            // ÊåâÈúÄ‰ΩøÁî®ÁöÑÂõæÊ†áÔºàÁªëÂÆöÂà∞ÊåâÈíÆÁöÑ :iconÔºâ
            const Refresh = ElementPlusIconsVue.Refresh;
            const Monitor = ElementPlusIconsVue.Monitor;
            const Document = ElementPlusIconsVue.Document;
            const Search = ElementPlusIconsVue.Search;

            // ÂØºËà™ËèúÂçï
            const activeMenu = ref('/metrics');
            const handleMenuSelect = (key) => {
                window.location.href = key;
            };

            const loading = ref(false);
            const error = ref('');
            const metrics = ref({});
            const lastUpdate = ref('');
            const chartInstances = {};

            // Ê†∏ÂøÉÊ¶ÇË¶ÅÊåáÊ†áÔºà‰∏çÂèÇ‰∏é‰∏ãÊãâÈÄâÊã©ÔºåÂßãÁªàÂú®Ê¶ÇËßàÂç°ÁâáÂ±ïÁ§∫Ôºâ
            const coreMetrics = [
                'data_acquisition_collection_latency_ms',
                'data_acquisition_collection_rate',
                'data_acquisition_queue_depth',
                'data_acquisition_errors_total'
            ];

            // ÂèØÈÄâÁöÑËØ¶ÁªÜÊåáÊ†áÈªòËÆ§ÂàóË°®Ôºà‰∏çÂê´Ê†∏ÂøÉÊ¶ÇË¶ÅÊåáÊ†áÔºâ
            const importantMetrics = [
                'data_acquisition_processing_latency_ms',
                'data_acquisition_write_latency_ms',
                'data_acquisition_batch_write_efficiency',
                'data_acquisition_connection_status_changes_total',
                'data_acquisition_connection_duration_seconds'
            ];

            const selectedMetrics = ref([]);
            const searchKeyword = ref('');
            const availableMetrics = ref([...importantMetrics]); // ‰∏çÂê´Ê†∏ÂøÉÊåáÊ†á
            // ÊÅ¢Â§çÂ∑≤ÈÄâÊã©ÁöÑÊåáÊ†á
            const storedSelected = localStorage.getItem('metrics-selected');
            if (storedSelected) {
                try {
                    const parsed = JSON.parse(storedSelected);
                    if (Array.isArray(parsed)) {
                        // ËøáÊª§ÊéâÊ†∏ÂøÉÊåáÊ†áÔºåÁ°Æ‰øù‰∏çÂèÇ‰∏éÂãæÈÄâ
                        selectedMetrics.value = parsed.filter(x => !coreMetrics.includes(x));
                    }
                } catch { /* ignore */ }
            }

            const filteredMetrics = computed(() => {
                const result = {};
                let sourceKeys = (selectedMetrics.value && selectedMetrics.value.length > 0)
                    ? selectedMetrics.value
                    : availableMetrics.value;

                // Â∫îÁî®ÊêúÁ¥¢ÂÖ≥ÈîÆËØçËøáÊª§
                if (searchKeyword.value && searchKeyword.value.trim()) {
                    const keyword = searchKeyword.value.toLowerCase();
                    sourceKeys = sourceKeys.filter(name => {
                        const title = getMetricTitle(name).toLowerCase();
                        return title.includes(keyword) || name.toLowerCase().includes(keyword);
                    });
                }

                sourceKeys.forEach(name => {
                    if (metrics.value[name]) {
                        result[name] = metrics.value[name];
                    } else {
                        // Âç≥‰ΩøÂΩìÂâçÊ≤°ÊúâÊï∞ÊçÆÔºå‰πü‰øùÁïôÂç°ÁâáÂç†‰ΩçÔºå‰æø‰∫éËßÇÂØü
                        result[name] = {
                            type: '',
                            help: 'ÊöÇÊó†Êï∞ÊçÆ',
                            data: []
                        };
                    }
                });

                // Â¶ÇÊûúÊ≤°ÊúâÂåπÈÖçÁöÑÔºåÂõûÈÄÄÂ±ïÁ§∫ÂÖ®ÈÉ®
                if (Object.keys(result).length === 0 && metrics.value) {
                    Object.keys(metrics.value).forEach(name => {
                        if (!coreMetrics.includes(name)) {
                            result[name] = metrics.value[name];
                        }
                    });
                }
                return result;
            });

            async function loadMetrics() {
                loading.value = true;
                error.value = '';

                try {
                    const response = await fetch('/api/metrics-data');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    metrics.value = data.metrics || {};
                    // Êõ¥Êñ∞ÂèØÈÄâÊåáÊ†áÂàóË°®ÔºöÈáçË¶ÅÊåáÊ†á + ËøîÂõûÊåáÊ†áÈîÆÔºàÊéíÈô§Ê†∏ÂøÉÊ¶ÇË¶ÅÊåáÊ†áÔºâ
                    const keys = Object.keys(metrics.value || {});
                    availableMetrics.value = Array.from(
                        new Set([...importantMetrics, ...keys.filter(k => !coreMetrics.includes(k))])
                    );
                    lastUpdate.value = new Date(data.timestamp).toLocaleString('zh-CN');

                    // Ê∏≤ÊüìÂõæË°®
                    setTimeout(() => {
                        renderCharts();
                    }, 100);
                } catch (err) {
                    error.value = err.message;
                    ElMessage.error('Âä†ËΩΩÊåáÊ†áÊï∞ÊçÆÂ§±Ë¥•: ' + err.message);
                } finally {
                    loading.value = false;
                }
            }

            function renderCharts() {
                Object.keys(filteredMetrics.value).forEach(metricName => {
                    const metric = filteredMetrics.value[metricName];
                    if (!metric.data || metric.data.length < 2) return;

                    const chartId = 'chart-' + metricName;
                    const chartDom = document.getElementById(chartId);
                    if (!chartDom) return;

                    // ÈîÄÊØÅÊóßÂõæË°®
                    if (chartInstances[metricName]) {
                        chartInstances[metricName].dispose();
                    }

                    // ÂàõÂª∫Êñ∞ÂõæË°®
                    const chart = echarts.init(chartDom);
                    const data = metric.data.map(d => d.value);
                    const labels = metric.data.map((_, i) => `#${i + 1}`);

                    chart.setOption({
                        tooltip: {
                            trigger: 'axis',
                            formatter: function (params) {
                                const point = metric.data[params[0].dataIndex];
                                let labelText = formatMetricValue(metricName, params[0].value);
                                if (point.labels) {
                                    labelText += '<br/>' + Object.entries(point.labels)
                                        .map(([k, v]) => `${k}: ${v}`)
                                        .join('<br/>');
                                }
                                return labelText;
                            }
                        },
                        grid: {
                            left: '3%',
                            right: '4%',
                            bottom: '3%',
                            containLabel: true
                        },
                        xAxis: {
                            type: 'category',
                            data: labels,
                            boundaryGap: false
                        },
                        yAxis: {
                            type: 'value',
                            name: getMetricUnit(metricName)
                        },
                        series: [{
                            name: getMetricTitle(metricName),
                            type: 'line',
                            smooth: true,
                            data: data,
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [{
                                        offset: 0, color: 'rgba(64, 158, 255, 0.3)'
                                    }, {
                                        offset: 1, color: 'rgba(64, 158, 255, 0.1)'
                                    }]
                                }
                            },
                            lineStyle: {
                                color: '#409eff',
                                width: 2
                            },
                            symbol: 'circle',
                            symbolSize: 6
                        }]
                    });

                    chartInstances[metricName] = chart;
                });
            }


            function getMetricTitle(metricName) {
                const titles = {
                    'data_acquisition_collection_latency_ms': 'ÈááÈõÜÂª∂Ëøü',
                    'data_acquisition_collection_rate': 'ÈááÈõÜÈ¢ëÁéá',
                    'data_acquisition_queue_depth': 'ÈòüÂàóÊ∑±Â∫¶ÔºàÊÄªÔºâ',
                    'data_acquisition_processing_latency_ms': 'Â§ÑÁêÜÂª∂Ëøü',
                    'data_acquisition_write_latency_ms': 'ÂÜôÂÖ•Âª∂Ëøü',
                    'data_acquisition_batch_write_efficiency': 'ÊâπÈáèÂÜôÂÖ•ÊïàÁéá',
                    'data_acquisition_errors_total': 'ÈîôËØØÊÄªÊï∞',
                    'data_acquisition_connection_status_changes_total': 'ËøûÊé•Áä∂ÊÄÅÂèòÂåñ',
                    'data_acquisition_connection_duration_seconds': 'ËøûÊé•ÊåÅÁª≠Êó∂Èó¥'
                };
                return titles[metricName] || metricName;
            }

            function getMetricUnit(metricName) {
                if (metricName.includes('latency_ms') || metricName.includes('_ms')) return 'ÊØ´Áßí';
                if (metricName.includes('_rate')) return 'points/s';
                if (metricName.includes('_seconds')) return 'Áßí';
                if (metricName.includes('_total')) return 'Ê¨°';
                if (metricName.includes('_depth')) return 'Ê∂àÊÅØÊï∞';
                return '';
            }

            function formatMetricValue(metricName, value) {
                if (value && typeof value === 'object' && 'value' in value) {
                    value = value.value;
                }
                if (typeof value !== 'number') return value;

                const unit = getMetricUnit(metricName);
                const fixed = value.toFixed(2);

                if (unit === 'ÊØ´Áßí') return fixed + ' ms';
                if (unit === 'points/s') return fixed + ' points/s';
                if (unit === 'Áßí') return fixed + ' s';
                if (unit === 'Ê∂àÊÅØÊï∞') return fixed + ' messages';
                if (unit === 'Ê¨°') return fixed + ' Ê¨°';
                if (metricName.includes('efficiency')) return fixed + ' points/ms';

                return fixed;
            }

            function getLatestValue(data) {
                if (!data || data.length === 0) return {value: 0};
                return data[data.length - 1];
            }

            function getMetricValue(metricName) {
                const metric = metrics.value[metricName];
                if (!metric || !metric.data || metric.data.length === 0) return 0;
                const value = getLatestValue(metric.data).value;
                return typeof value === 'number' ? value : 0;
            }

            function getMetricType(type) {
                const types = {
                    'histogram': 'success',
                    'counter': 'warning',
                    'gauge': 'info'
                };
                return types[type] || '';
            }

            function searchMetrics() {
                // ÊêúÁ¥¢ÂäüËÉΩÁî± computed filteredMetrics Ëá™Âä®Â§ÑÁêÜ
                // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†È¢ùÂ§ñÁöÑÊêúÁ¥¢ÈÄªËæëÔºåÂ¶ÇÊûúÈúÄË¶ÅÁöÑËØù
            }

            function clearFilters() {
                selectedMetrics.value = [];
                searchKeyword.value = '';
                // Ê∏ÖÁ©∫Êú¨Âú∞Â≠òÂÇ®
                localStorage.removeItem('metrics-selected');
            }

            onMounted(() => {
                loadMetrics();
            });

            // ËÆ∞‰ΩèÈÄâÊã©
            watch(selectedMetrics, (val) => {
                localStorage.setItem('metrics-selected', JSON.stringify(val || []));
            }, {deep: true});

            onUnmounted(() => {
                Object.values(chartInstances).forEach(chart => {
                    if (chart) chart.dispose();
                });
            });

            return {
                loading,
                error,
                metrics,
                lastUpdate,
                Refresh,
                Monitor,
                Document,
                activeMenu,
                handleMenuSelect,
                selectedMetrics,
                searchKeyword,
                availableMetrics,
                filteredMetrics,
                loadMetrics,
                searchMetrics,
                clearFilters,
                getMetricTitle,
                getMetricUnit,
                formatMetricValue,
                getLatestValue,
                getMetricValue,
                getMetricType,
                Search
            };
        }
    })

    // ÂÖ®Â±ÄÊ≥®ÂÜå Element Plus ÂõæÊ†áÔºåËß£ÂÜ≥ <Monitor/> Á≠âÁªÑ‰ª∂Ëß£ÊûêÈóÆÈ¢ò
    Object.entries(ElementPlusIconsVue).forEach(([name, component]) => {
        app.component(name, component);
    });

    // ÈÖçÁΩÆ‰∏≠ÊñáËØ≠Ë®Ä
    app.use(ElementPlus, {
        locale: zhCn
    });
    app.mount('#app');
</script>
</body>

</html>


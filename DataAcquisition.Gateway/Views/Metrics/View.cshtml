@{
    ViewData["Title"] = "Á≥ªÁªüÊåáÊ†áÁõëÊéß";
    Layout = null;
}

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@ViewData["Title"]</title>

    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css" />
    <!-- Element Plus Icons -->
    <link rel="stylesheet" href="https://unpkg.com/@@element-plus/icons-vue/dist/index.css" />

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f7fa;
        }

        #app {
            min-height: 100vh;
        }

        .metrics-container {
            padding: 20px;
        }

        .metric-card {
            margin-bottom: 20px;
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .metric-title {
            font-size: 16px;
            font-weight: 600;
            color: #303133;
        }

        .metric-value {
            font-size: 28px;
            font-weight: bold;
            color: #409eff;
            margin: 10px 0;
        }

        .metric-description {
            font-size: 12px;
            color: #909399;
            margin-top: 5px;
        }

        .metric-tags {
            margin-top: 10px;
        }

        .chart-wrapper {
            margin-top: 15px;
            height: 250px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .refresh-info {
            color: #909399;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="app">
        <el-container>
            <el-header style="background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 0 20px; display: flex; align-items: center; justify-content: space-between;">
                <div>
                    <h2 style="margin: 0; color: #303133;">
                        <el-icon><Monitor /></el-icon>
                        Á≥ªÁªüÊåáÊ†áÁõëÊéß
                    </h2>
                    <div class="refresh-info" style="margin-top: 5px;">
                        <span v-if="lastUpdate">ÊúÄÂêéÊõ¥Êñ∞: {{ lastUpdate }}</span>
                        <span v-else>Ê≠£Âú®Âä†ËΩΩ...</span>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <el-button type="primary" :icon="Refresh" @@click="loadMetrics" :loading="loading">
                        Âà∑Êñ∞
                    </el-button>
                    <el-button v-if="autoRefresh" type="info" @@click="toggleAutoRefresh">
                        Ëá™Âä®Âà∑Êñ∞: ÂºÄÂêØ
                    </el-button>
                    <el-button v-else @@click="toggleAutoRefresh">
                        Ëá™Âä®Âà∑Êñ∞: ÂÖ≥Èó≠
                    </el-button>
                    <el-select
                        v-model="selectedMetrics"
                        multiple
                        clearable
                        collapse-tags
                        filterable
                        placeholder="ÈÄâÊã©Ë¶ÅÂ±ïÁ§∫ÁöÑÊåáÊ†á"
                        style="min-width: 260px;"
                    >
                        <el-option
                            v-for="name in availableMetrics"
                            :key="name"
                            :label="getMetricTitle(name)"
                            :value="name"
                        > </el-option>
                    </el-select>
                </div>
            </el-header>

            <el-main class="metrics-container">
                <el-alert
                    v-if="error"
                    :title="error"
                    type="error"
                    :closable="false"
                    style="margin-bottom: 20px;"
                > </el-alert>

                <div v-if="loading && !metrics" style="text-align: center; padding: 40px;">
                    <el-icon class="is-loading" style="font-size: 32px;"><Loading /></el-icon>
                    <p style="margin-top: 10px; color: #909399;">Ê≠£Âú®Âä†ËΩΩÊåáÊ†áÊï∞ÊçÆ...</p>
                </div>

                <div v-else-if="Object.keys(metrics).length === 0" style="text-align: center; padding: 40px;">
                    <el-empty description="ÊöÇÊó†ÊåáÊ†áÊï∞ÊçÆÔºåËØ∑Á°Æ‰øùÁ≥ªÁªüÊ≠£Âú®ËøêË°åÂπ∂‰∫ßÁîüÊåáÊ†á"></el-empty>
                </div>

                <div v-else>
                    <!-- ÂÖ≥ÈîÆÊåáÊ†áÊ¶ÇËßà -->
                    <el-card class="metric-card" shadow="hover">
                        <template #header>
                            <div class="metric-header">
                                <span class="metric-title">üìä ÂÖ≥ÈîÆÊåáÊ†áÊ¶ÇËßà</span>
                            </div>
                        </template>
                        <div class="stats-grid">
                            <el-statistic title="ÈááÈõÜÂª∂Ëøü" :value="getMetricValue('data_acquisition_collection_latency_ms')" suffix="ms">
                                <template #prefix>
                                    <el-icon style="vertical-align: -0.125em;"><Timer /></el-icon>
                                </template>
                            </el-statistic>
                            <el-statistic title="ÈááÈõÜÈ¢ëÁéá" :value="getMetricValue('data_acquisition_collection_rate')" suffix="points/s">
                                <template #prefix>
                                    <el-icon style="vertical-align: -0.125em;"><DataLine /></el-icon>
                                </template>
                            </el-statistic>
                            <el-statistic title="ÈòüÂàóÊ∑±Â∫¶" :value="getMetricValue('data_acquisition_queue_depth')" suffix="messages">
                                <template #prefix>
                                    <el-icon style="vertical-align: -0.125em;"><Box /></el-icon>
                                </template>
                            </el-statistic>
                            <el-statistic title="ÈîôËØØÊÄªÊï∞" :value="getMetricValue('data_acquisition_errors_total')">
                                <template #prefix>
                                    <el-icon style="vertical-align: -0.125em; color: #f56c6c;"><Warning /></el-icon>
                                </template>
                            </el-statistic>
                        </div>
                    </el-card>

                    <!-- ËØ¶ÁªÜÊåáÊ†áÂç°Áâá -->
                    <el-card
                        v-for="(metric, metricName) in filteredMetrics"
                        :key="metricName"
                        class="metric-card"
                        shadow="hover"
                    >
                        <template #header>
                            <div class="metric-header">
                                <span class="metric-title">{{ getMetricTitle(metricName) }}</span>
                                <el-tag :type="getMetricType(metric.type)">{{ metric.type }}</el-tag>
                            </div>
                        </template>

                        <div v-if="metric.data && metric.data.length > 0">
                            <!-- ÊúÄÊñ∞ÂÄº -->
                            <div class="metric-value">
                                {{ formatMetricValue(metricName, getLatestValue(metric.data).value ?? getLatestValue(metric.data)) }}
                            </div>

                            <!-- ÊèèËø∞ -->
                            <div class="metric-description" v-if="metric.help">
                                {{ metric.help }}
                            </div>

                            <!-- Ê†áÁ≠æ -->
                            <div class="metric-tags" v-if="getLatestValue(metric.data).labels">
                                <el-tag
                                    v-for="(value, key) in getLatestValue(metric.data).labels"
                                    :key="key"
                                    size="small"
                                    style="margin-right: 8px; margin-bottom: 8px;"
                                >
                                    <strong>{{ key }}:</strong> {{ value }}
                                </el-tag>
                            </div>

                            <!-- ÂõæË°® -->
                            <div class="chart-wrapper" v-if="metric.data.length > 1">
                                <el-divider></el-divider>
                                <div :id="'chart-' + metricName" style="height: 250px;"></div>
                            </div>

                            <!-- Êï∞ÊçÆË°®Ê†º -->
                            <el-table
                                v-if="metric.data.length > 0"
                                :data="metric.data.slice(-10).reverse()"
                                size="small"
                                style="margin-top: 15px;"
                                max-height="200"
                            >
                                <el-table-column prop="value" label="ÂÄº" width="120">
                                    <template #default="scope">
                                        {{ formatMetricValue(metricName, scope.row.value) }}
                                    </template>
                                </el-table-column>
                                <el-table-column label="Ê†áÁ≠æ" min-width="200">
                                    <template #default="scope">
                                        <el-tag
                                            v-for="(value, key) in scope.row.labels"
                                            :key="key"
                                            size="small"
                                            style="margin-right: 5px;"
                                        >
                                            {{ key }}: {{ value }}
                                        </el-tag>
                                    </template>
                                </el-table-column>
                            </el-table>
                        </div>

                        <el-empty v-else description="ÊöÇÊó†Êï∞ÊçÆ" :image-size="80" />
                    </el-card>
                </div>
            </el-main>
        </el-container>
    </div>

    <!-- Vue 3 (production build) -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <!-- Element Plus -->
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <!-- Element Plus Icons -->
    <script src="https://unpkg.com/@@element-plus/icons-vue/dist/index.iife.js"></script>
    <!-- ECharts for charts -->
    <script src="https://unpkg.com/echarts@5/dist/echarts.min.js"></script>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, watch } = Vue;
        const { ElMessage } = ElementPlus;

        const app = createApp({
            setup() {
                // ÊåâÈúÄ‰ΩøÁî®ÁöÑÂõæÊ†áÔºàÁªëÂÆöÂà∞ÊåâÈíÆÁöÑ :iconÔºâ
                const Refresh = ElementPlusIconsVue.Refresh;

                const loading = ref(false);
                const error = ref('');
                const metrics = ref({});
                const lastUpdate = ref('');
                const autoRefresh = ref(false);
                let refreshTimer = null;
                const chartInstances = {};

                // Ê†∏ÂøÉÊ¶ÇË¶ÅÊåáÊ†áÔºà‰∏çÂèÇ‰∏é‰∏ãÊãâÈÄâÊã©ÔºåÂßãÁªàÂú®Ê¶ÇËßàÂç°ÁâáÂ±ïÁ§∫Ôºâ
                const coreMetrics = [
                    'data_acquisition_collection_latency_ms',
                    'data_acquisition_collection_rate',
                    'data_acquisition_queue_depth',
                    'data_acquisition_errors_total'
                ];

                // ÂèØÈÄâÁöÑËØ¶ÁªÜÊåáÊ†áÈªòËÆ§ÂàóË°®Ôºà‰∏çÂê´Ê†∏ÂøÉÊ¶ÇË¶ÅÊåáÊ†áÔºâ
                const importantMetrics = [
                    'data_acquisition_processing_latency_ms',
                    'data_acquisition_write_latency_ms',
                    'data_acquisition_batch_write_efficiency',
                    'data_acquisition_connection_status_changes_total',
                    'data_acquisition_connection_duration_seconds'
                ];

                const selectedMetrics = ref([]);
                const availableMetrics = ref([...importantMetrics]); // ‰∏çÂê´Ê†∏ÂøÉÊåáÊ†á
                // ÊÅ¢Â§çÂ∑≤ÈÄâÊã©ÁöÑÊåáÊ†á
                const storedSelected = localStorage.getItem('metrics-selected');
                if (storedSelected) {
                    try {
                        const parsed = JSON.parse(storedSelected);
                        if (Array.isArray(parsed)) {
                            // ËøáÊª§ÊéâÊ†∏ÂøÉÊåáÊ†áÔºåÁ°Æ‰øù‰∏çÂèÇ‰∏éÂãæÈÄâ
                            selectedMetrics.value = parsed.filter(x => !coreMetrics.includes(x));
                        }
                    } catch { /* ignore */ }
                }

                const filteredMetrics = computed(() => {
                    const result = {};
                    const sourceKeys = (selectedMetrics.value && selectedMetrics.value.length > 0)
                        ? selectedMetrics.value
                        : availableMetrics.value;

                    sourceKeys.forEach(name => {
                        if (metrics.value[name]) {
                            result[name] = metrics.value[name];
                        } else {
                            // Âç≥‰ΩøÂΩìÂâçÊ≤°ÊúâÊï∞ÊçÆÔºå‰πü‰øùÁïôÂç°ÁâáÂç†‰ΩçÔºå‰æø‰∫éËßÇÂØü
                            result[name] = {
                                type: '',
                                help: 'ÊöÇÊó†Êï∞ÊçÆ',
                                data: []
                            };
                        }
                    });

                    // Â¶ÇÊûúÊ≤°ÊúâÂåπÈÖçÁöÑÔºåÂõûÈÄÄÂ±ïÁ§∫ÂÖ®ÈÉ®
                    if (Object.keys(result).length === 0 && metrics.value) {
                        Object.keys(metrics.value).forEach(name => {
                            if (!coreMetrics.includes(name)) {
                                result[name] = metrics.value[name];
                            }
                        });
                    }
                    return result;
                });

                async function loadMetrics() {
                    loading.value = true;
                    error.value = '';

                    try {
                        const response = await fetch('/api/metrics-data');
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const data = await response.json();
                        metrics.value = data.metrics || {};
                        // Êõ¥Êñ∞ÂèØÈÄâÊåáÊ†áÂàóË°®ÔºöÈáçË¶ÅÊåáÊ†á + ËøîÂõûÊåáÊ†áÈîÆÔºàÊéíÈô§Ê†∏ÂøÉÊ¶ÇË¶ÅÊåáÊ†áÔºâ
                        const keys = Object.keys(metrics.value || {});
                        availableMetrics.value = Array.from(
                            new Set([...importantMetrics, ...keys.filter(k => !coreMetrics.includes(k))])
                        );
                        lastUpdate.value = new Date(data.timestamp).toLocaleString('zh-CN');

                        // Ê∏≤ÊüìÂõæË°®
                        setTimeout(() => {
                            renderCharts();
                        }, 100);
                    } catch (err) {
                        error.value = err.message;
                        ElMessage.error('Âä†ËΩΩÊåáÊ†áÊï∞ÊçÆÂ§±Ë¥•: ' + err.message);
                    } finally {
                        loading.value = false;
                    }
                }

                function renderCharts() {
                    Object.keys(filteredMetrics.value).forEach(metricName => {
                        const metric = filteredMetrics.value[metricName];
                        if (!metric.data || metric.data.length < 2) return;

                        const chartId = 'chart-' + metricName;
                        const chartDom = document.getElementById(chartId);
                        if (!chartDom) return;

                        // ÈîÄÊØÅÊóßÂõæË°®
                        if (chartInstances[metricName]) {
                            chartInstances[metricName].dispose();
                        }

                        // ÂàõÂª∫Êñ∞ÂõæË°®
                        const chart = echarts.init(chartDom);
                        const data = metric.data.map(d => d.value);
                        const labels = metric.data.map((_, i) => `#${i + 1}`);

                        chart.setOption({
                            tooltip: {
                                trigger: 'axis',
                                formatter: function(params) {
                                    const point = metric.data[params[0].dataIndex];
                                    let labelText = formatMetricValue(metricName, params[0].value);
                                    if (point.labels) {
                                        labelText += '<br/>' + Object.entries(point.labels)
                                            .map(([k, v]) => `${k}: ${v}`)
                                            .join('<br/>');
                                    }
                                    return labelText;
                                }
                            },
                            grid: {
                                left: '3%',
                                right: '4%',
                                bottom: '3%',
                                containLabel: true
                            },
                            xAxis: {
                                type: 'category',
                                data: labels,
                                boundaryGap: false
                            },
                            yAxis: {
                                type: 'value',
                                name: getMetricUnit(metricName)
                            },
                            series: [{
                                name: getMetricTitle(metricName),
                                type: 'line',
                                smooth: true,
                                data: data,
                                areaStyle: {
                                    color: {
                                        type: 'linear',
                                        x: 0,
                                        y: 0,
                                        x2: 0,
                                        y2: 1,
                                        colorStops: [{
                                            offset: 0, color: 'rgba(64, 158, 255, 0.3)'
                                        }, {
                                            offset: 1, color: 'rgba(64, 158, 255, 0.1)'
                                        }]
                                    }
                                },
                                lineStyle: {
                                    color: '#409eff',
                                    width: 2
                                },
                                symbol: 'circle',
                                symbolSize: 6
                            }]
                        });

                        chartInstances[metricName] = chart;
                    });
                }

                function toggleAutoRefresh() {
                    autoRefresh.value = !autoRefresh.value;
                    if (autoRefresh.value) {
                        refreshTimer = setInterval(loadMetrics, 5000); // ÊØè5ÁßíÂà∑Êñ∞
                        ElMessage.success('Â∑≤ÂºÄÂêØËá™Âä®Âà∑Êñ∞');
                    } else {
                        if (refreshTimer) {
                            clearInterval(refreshTimer);
                            refreshTimer = null;
                        }
                        ElMessage.info('Â∑≤ÂÖ≥Èó≠Ëá™Âä®Âà∑Êñ∞');
                    }
                }

                function getMetricTitle(metricName) {
                    const titles = {
                        'data_acquisition_collection_latency_ms': 'ÈááÈõÜÂª∂Ëøü',
                        'data_acquisition_collection_rate': 'ÈááÈõÜÈ¢ëÁéá',
                        'data_acquisition_queue_depth': 'ÈòüÂàóÊ∑±Â∫¶',
                        'data_acquisition_processing_latency_ms': 'Â§ÑÁêÜÂª∂Ëøü',
                        'data_acquisition_write_latency_ms': 'ÂÜôÂÖ•Âª∂Ëøü',
                        'data_acquisition_batch_write_efficiency': 'ÊâπÈáèÂÜôÂÖ•ÊïàÁéá',
                        'data_acquisition_errors_total': 'ÈîôËØØÊÄªÊï∞',
                        'data_acquisition_connection_status_changes_total': 'ËøûÊé•Áä∂ÊÄÅÂèòÂåñ',
                        'data_acquisition_connection_duration_seconds': 'ËøûÊé•ÊåÅÁª≠Êó∂Èó¥'
                    };
                    return titles[metricName] || metricName;
                }

                function getMetricUnit(metricName) {
                    if (metricName.includes('latency_ms') || metricName.includes('_ms')) return 'ÊØ´Áßí';
                    if (metricName.includes('_rate')) return 'points/s';
                    if (metricName.includes('_seconds')) return 'Áßí';
                    if (metricName.includes('_total')) return 'Ê¨°';
                    if (metricName.includes('_depth')) return 'Ê∂àÊÅØÊï∞';
                    return '';
                }

                function formatMetricValue(metricName, value) {
                    if (value && typeof value === 'object' && 'value' in value) {
                        value = value.value;
                    }
                    if (typeof value !== 'number') return value;

                    const unit = getMetricUnit(metricName);
                    const fixed = value.toFixed(2);

                    if (unit === 'ÊØ´Áßí') return fixed + ' ms';
                    if (unit === 'points/s') return fixed + ' points/s';
                    if (unit === 'Áßí') return fixed + ' s';
                    if (unit === 'Ê∂àÊÅØÊï∞') return fixed + ' messages';
                    if (unit === 'Ê¨°') return fixed + ' Ê¨°';
                    if (metricName.includes('efficiency')) return fixed + ' points/ms';

                    return fixed;
                }

                function getLatestValue(data) {
                    if (!data || data.length === 0) return { value: 0 };
                    return data[data.length - 1];
                }

                function getMetricValue(metricName) {
                    const metric = metrics.value[metricName];
                    if (!metric || !metric.data || metric.data.length === 0) return 0;
                    const value = getLatestValue(metric.data).value;
                    return typeof value === 'number' ? value : 0;
                }

                function getMetricType(type) {
                    const types = {
                        'histogram': 'success',
                        'counter': 'warning',
                        'gauge': 'info'
                    };
                    return types[type] || '';
                }

                onMounted(() => {
                    loadMetrics();
                });

                // ËÆ∞‰ΩèÈÄâÊã©
                watch(selectedMetrics, (val) => {
                    localStorage.setItem('metrics-selected', JSON.stringify(val || []));
                }, { deep: true });

                onUnmounted(() => {
                    if (refreshTimer) {
                        clearInterval(refreshTimer);
                    }
                    Object.values(chartInstances).forEach(chart => {
                        if (chart) chart.dispose();
                    });
                });

                return {
                    loading,
                    error,
                    metrics,
                    lastUpdate,
                    autoRefresh,
                    selectedMetrics,
                    availableMetrics,
                    filteredMetrics,
                    loadMetrics,
                    toggleAutoRefresh,
                    getMetricTitle,
                    getMetricUnit,
                    formatMetricValue,
                    getLatestValue,
                    getMetricValue,
                    getMetricType,
                    Refresh
                };
            }
        })

        // ÂÖ®Â±ÄÊ≥®ÂÜå Element Plus ÂõæÊ†áÔºåËß£ÂÜ≥ <Monitor/> Á≠âÁªÑ‰ª∂Ëß£ÊûêÈóÆÈ¢ò
        Object.entries(ElementPlusIconsVue).forEach(([name, component]) => {
            app.component(name, component);
        });

        app.use(ElementPlus);
        app.mount('#app');
    </script>
</body>
</html>
